{"version":3,"file":"_list-navigation-chunk.mjs","sources":["../../../../../darwin_arm64-fastbuild-ST-fdfa778d11ba/bin/src/aria/private/behaviors/list-focus/list-focus.ts","../../../../../darwin_arm64-fastbuild-ST-fdfa778d11ba/bin/src/aria/private/behaviors/list-navigation/list-navigation.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {computed, signal, SignalLike, WritableSignalLike} from '../signal-like/signal-like';\n\n/** Represents an item in a collection, such as a listbox option, than may receive focus. */\nexport interface ListFocusItem {\n  /** A unique identifier for the item. */\n  id: SignalLike<string>;\n\n  /** The html element that should receive focus. */\n  element: SignalLike<HTMLElement | undefined>;\n\n  /** Whether an item is disabled. */\n  disabled: SignalLike<boolean>;\n\n  /** The index of the item in the list. */\n  index: SignalLike<number>;\n}\n\n/** Represents the required inputs for a collection that contains focusable items. */\nexport interface ListFocusInputs<T extends ListFocusItem> {\n  /** The focus strategy used by the list. */\n  focusMode: SignalLike<'roving' | 'activedescendant'>;\n\n  /** Whether the list is disabled. */\n  disabled: SignalLike<boolean>;\n\n  /** The items in the list. */\n  items: SignalLike<T[]>;\n\n  /** The active item. */\n  activeItem: WritableSignalLike<T | undefined>;\n\n  /** Whether disabled items in the list should be focusable. */\n  softDisabled: SignalLike<boolean>;\n\n  /** The html element that should receive focus. */\n  element: SignalLike<HTMLElement | undefined>;\n}\n\n/** Controls focus for a list of items. */\nexport class ListFocus<T extends ListFocusItem> {\n  /** The last item that was active. */\n  prevActiveItem = signal<T | undefined>(undefined);\n\n  /** The index of the last item that was active. */\n  prevActiveIndex = computed(() => {\n    return this.prevActiveItem() ? this.inputs.items().indexOf(this.prevActiveItem()!) : -1;\n  });\n\n  /** The current active index in the list. */\n  activeIndex = computed(() => {\n    return this.inputs.activeItem() ? this.inputs.items().indexOf(this.inputs.activeItem()!) : -1;\n  });\n\n  constructor(readonly inputs: ListFocusInputs<T>) {}\n\n  /** Whether the list is in a disabled state. */\n  isListDisabled(): boolean {\n    return this.inputs.disabled() || this.inputs.items().every(i => i.disabled());\n  }\n\n  /** The id of the current active item. */\n  getActiveDescendant(): string | undefined {\n    if (this.isListDisabled()) {\n      return undefined;\n    }\n    if (this.inputs.focusMode() === 'roving') {\n      return undefined;\n    }\n    return this.inputs.activeItem()?.id() ?? undefined;\n  }\n\n  /** The tab index for the list. */\n  getListTabIndex(): -1 | 0 {\n    if (this.isListDisabled()) {\n      return 0;\n    }\n    return this.inputs.focusMode() === 'activedescendant' ? 0 : -1;\n  }\n\n  /** Returns the tab index for the given item. */\n  getItemTabIndex(item: T): -1 | 0 {\n    if (this.isListDisabled()) {\n      return -1;\n    }\n    if (this.inputs.focusMode() === 'activedescendant') {\n      return -1;\n    }\n    return this.inputs.activeItem() === item ? 0 : -1;\n  }\n\n  /** Moves focus to the given item if it is focusable. */\n  focus(item: T, opts?: {focusElement?: boolean}): boolean {\n    if (this.isListDisabled() || !this.isFocusable(item)) {\n      return false;\n    }\n\n    this.prevActiveItem.set(this.inputs.activeItem());\n    this.inputs.activeItem.set(item);\n\n    if (opts?.focusElement || opts?.focusElement === undefined) {\n      this.inputs.focusMode() === 'roving'\n        ? item.element()?.focus()\n        : this.inputs.element()?.focus();\n    }\n\n    return true;\n  }\n\n  /** Returns true if the given item can be navigated to. */\n  isFocusable(item: T): boolean {\n    return !item.disabled() || this.inputs.softDisabled();\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {SignalLike} from '../signal-like/signal-like';\nimport {ListFocus, ListFocusInputs, ListFocusItem} from '../list-focus/list-focus';\n\n/** Represents an item in a collection, such as a listbox option, than can be navigated to. */\nexport interface ListNavigationItem extends ListFocusItem {}\n\n/** Represents the required inputs for a collection that has navigable items. */\nexport interface ListNavigationInputs<T extends ListNavigationItem> extends ListFocusInputs<T> {\n  /** Whether focus should wrap when navigating. */\n  wrap: SignalLike<boolean>;\n\n  /** Whether the list is vertically or horizontally oriented. */\n  orientation: SignalLike<'vertical' | 'horizontal'>;\n\n  /** The direction that text is read based on the users locale. */\n  textDirection: SignalLike<'rtl' | 'ltr'>;\n}\n\n/** Options for list navigation. */\nexport interface ListNavigationOpts<T> {\n  /**\n   * Whether to focus the item's element.\n   * Defaults to true.\n   */\n  focusElement?: boolean;\n\n  /**\n   * The list of items to navigate through.\n   * Defaults to the list of items from the inputs.\n   */\n  items?: T[];\n}\n\n/** Controls navigation for a list of items. */\nexport class ListNavigation<T extends ListNavigationItem> {\n  constructor(readonly inputs: ListNavigationInputs<T> & {focusManager: ListFocus<T>}) {}\n\n  /** Navigates to the given item. */\n  goto(item?: T, opts?: ListNavigationOpts<T>): boolean {\n    return item ? this.inputs.focusManager.focus(item, opts) : false;\n  }\n\n  /** Navigates to the next item in the list. */\n  next(opts?: ListNavigationOpts<T>): boolean {\n    return this._advance(1, opts);\n  }\n\n  /** Peeks the next item in the list. */\n  peekNext(opts?: ListNavigationOpts<T>): T | undefined {\n    return this._peek(1, opts);\n  }\n\n  /** Navigates to the previous item in the list. */\n  prev(opts?: ListNavigationOpts<T>): boolean {\n    return this._advance(-1, opts);\n  }\n\n  /** Peeks the previous item in the list. */\n  peekPrev(opts?: ListNavigationOpts<T>): T | undefined {\n    return this._peek(-1, opts);\n  }\n\n  /** Navigates to the first item in the list. */\n  first(opts?: ListNavigationOpts<T>): boolean {\n    const item = this.peekFirst(opts);\n    return item ? this.goto(item, opts) : false;\n  }\n\n  /** Navigates to the last item in the list. */\n  last(opts?: ListNavigationOpts<T>): boolean {\n    const item = this.peekLast(opts);\n    return item ? this.goto(item, opts) : false;\n  }\n\n  /** Gets the first focusable item from the given list of items. */\n  peekFirst(opts?: ListNavigationOpts<T>): T | undefined {\n    const items = opts?.items ?? this.inputs.items();\n    return items.find(i => this.inputs.focusManager.isFocusable(i));\n  }\n\n  /** Gets the last focusable item from the given list of items. */\n  peekLast(opts?: ListNavigationOpts<T>): T | undefined {\n    const items = opts?.items ?? this.inputs.items();\n    for (let i = items.length - 1; i >= 0; i--) {\n      if (this.inputs.focusManager.isFocusable(items[i])) {\n        return items[i];\n      }\n    }\n    return;\n  }\n\n  /** Advances to the next or previous focusable item in the list based on the given delta. */\n  private _advance(delta: 1 | -1, opts?: ListNavigationOpts<T>): boolean {\n    const item = this._peek(delta, opts);\n    return item ? this.goto(item, opts) : false;\n  }\n\n  /** Peeks the next or previous focusable item in the list based on the given delta. */\n  private _peek(delta: 1 | -1, opts?: ListNavigationOpts<T>): T | undefined {\n    const items = opts?.items ?? this.inputs.items();\n    const itemCount = items.length;\n    const activeItem = this.inputs.focusManager.inputs.activeItem();\n    const startIndex =\n      opts?.items && activeItem\n        ? items.indexOf(activeItem)\n        : this.inputs.focusManager.activeIndex();\n\n    const step = (i: number) =>\n      this.inputs.wrap() ? (i + delta + itemCount) % itemCount : i + delta;\n\n    // If wrapping is enabled, this loop ultimately terminates when `i` gets back to `startIndex`\n    // in the case that all options are disabled. If wrapping is disabled, the loop terminates\n    // when the index goes out of bounds.\n    for (let i = step(startIndex); i !== startIndex && i < itemCount && i >= 0; i = step(i)) {\n      if (this.inputs.focusManager.isFocusable(items[i])) {\n        return items[i];\n      }\n    }\n\n    return;\n  }\n}\n"],"names":["ListFocus","inputs","prevActiveItem","signal","undefined","prevActiveIndex","computed","items","indexOf","activeIndex","activeItem","constructor","isListDisabled","disabled","every","i","getActiveDescendant","focusMode","id","getListTabIndex","getItemTabIndex","item","focus","opts","isFocusable","set","focusElement","element","softDisabled","ListNavigation","goto","focusManager","next","_advance","peekNext","_peek","prev","peekPrev","first","peekFirst","last","peekLast","find","length","delta","itemCount","startIndex","step","wrap"],"mappings":"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"}